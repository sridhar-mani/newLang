import { BUILTIN_UNIFORMS } from './ast';
export class JSCodeGenerator {
    options;
    output = [];
    constructor(options = {}) {
        this.options = {
            format: 'esm',
            typescript: true,
            react: false,
            embedWGSL: true,
            ...options
        };
    }
    generate(ast, wgslCode) {
        this.output = [];
        // Header
        this.emit('// Generated by Shader3D - Do not edit directly');
        this.emit('');
        // Imports
        this.generateImports(ast);
        // Type exports (TypeScript only)
        if (this.options.typescript) {
            this.generateTypeExports(ast);
        }
        // Embedded WGSL
        if (this.options.embedWGSL) {
            this.generateEmbeddedWGSL(wgslCode);
        }
        // Uniform buffer helpers
        this.generateUniformHelpers(ast);
        // Pipeline factory functions
        this.generatePipelineFactories(ast);
        // React hooks (if enabled)
        if (this.options.react) {
            this.generateReactHooks(ast);
        }
        // Main exports
        this.generateExports(ast);
        return this.output.join('\n');
    }
    generateImports(_ast) {
        if (this.options.react) {
            this.emit("import { useEffect, useRef, useState, useCallback } from 'react';");
        }
        this.emit('');
    }
    generateTypeExports(ast) {
        // Generate TypeScript interfaces for shared types
        ast.sharedTypes.forEach(type => {
            this.emit(`export interface ${type.name} {`);
            type.fields.forEach(field => {
                const tsType = this.typeToTS(field.type);
                this.emit(`  ${field.name}: ${tsType};`);
            });
            this.emit('}');
            this.emit('');
        });
        // Generate uniform interface
        if (ast.gpuShaders.length > 0) {
            this.emit('export interface Shader3DUniforms {');
            BUILTIN_UNIFORMS.forEach(u => {
                const tsType = this.typeToTS(u.type);
                this.emit(`  /** ${u.description} */`);
                this.emit(`  ${u.name}: ${tsType};`);
            });
            this.emit('}');
            this.emit('');
        }
    }
    generateEmbeddedWGSL(wgslCode) {
        // Escape template literals
        const escaped = wgslCode.replace(/\\/g, '\\\\').replace(/`/g, '\\`').replace(/\$/g, '\\$');
        this.emit('/**');
        this.emit(' * WGSL shader code');
        this.emit(' * @see https://www.w3.org/TR/WGSL/');
        this.emit(' */');
        this.emit(`export const shaderCode = \`${escaped}\`;`);
        this.emit('');
    }
    generateUniformHelpers(ast) {
        // Calculate byte sizes for structs
        ast.sharedTypes.forEach(type => {
            const byteSize = this.calculateByteSize(type);
            this.emit(`/** Byte size of ${type.name} struct (with proper alignment) */`);
            this.emit(`export const ${type.name}ByteSize = ${byteSize};`);
            this.emit('');
            // Generate struct writer function
            this.generateStructWriter(type);
        });
        // Builtin uniforms byte size
        this.emit('/** Byte size of Shader3D builtin uniforms */');
        this.emit('export const Shader3DUniformsByteSize = 32; // time(4) + deltaTime(4) + frame(4) + pad(4) + resolution(8) + mouse(16)');
        this.emit('');
        // Helper to write builtin uniforms
        this.emit(`/**
 * Write Shader3D uniforms to a Float32Array
 * @param time - Elapsed time in seconds
 * @param deltaTime - Time since last frame
 * @param frame - Frame counter
 * @param resolution - Canvas size [width, height]
 * @param mouse - Mouse position [x, y, clickX, clickY]
 */
export function writeShader3DUniforms(
  buffer: Float32Array,
  time: number,
  deltaTime: number,
  frame: number,
  resolution: [number, number],
  mouse: [number, number, number, number]
): void {
  buffer[0] = time;
  buffer[1] = deltaTime;
  buffer[2] = frame;
  buffer[3] = 0; // padding
  buffer[4] = resolution[0];
  buffer[5] = resolution[1];
  buffer[6] = mouse[0];
  buffer[7] = mouse[1];
  buffer[8] = mouse[2];
  buffer[9] = mouse[3];
}`);
        this.emit('');
    }
    generateStructWriter(type) {
        this.emit(`/**`);
        this.emit(` * Write ${type.name} to a typed array at the given byte offset`);
        this.emit(` */`);
        this.emit(`export function write${type.name}(buffer: ArrayBuffer, offset: number, data: ${type.name}): void {`);
        this.emit(`  const view = new DataView(buffer, offset);`);
        let byteOffset = 0;
        type.fields.forEach(field => {
            const { size, alignment } = this.getTypeInfo(field.type);
            // Align
            byteOffset = Math.ceil(byteOffset / alignment) * alignment;
            this.emitFieldWriter(field, byteOffset);
            byteOffset += size;
        });
        this.emit('}');
        this.emit('');
    }
    emitFieldWriter(field, offset) {
        const { type } = field;
        switch (type.kind) {
            case 'primitive':
                if (type.name === 'f32' || type.name === 'number') {
                    this.emit(`  view.setFloat32(${offset}, data.${field.name}, true);`);
                }
                else if (type.name === 'i32') {
                    this.emit(`  view.setInt32(${offset}, data.${field.name}, true);`);
                }
                else if (type.name === 'u32') {
                    this.emit(`  view.setUint32(${offset}, data.${field.name}, true);`);
                }
                break;
            case 'vector':
                for (let i = 0; i < type.size; i++) {
                    const components = ['x', 'y', 'z', 'w'];
                    this.emit(`  view.setFloat32(${offset + i * 4}, data.${field.name}.${components[i]}, true);`);
                }
                break;
            case 'matrix':
                // Matrices are column-major
                for (let col = 0; col < type.cols; col++) {
                    for (let row = 0; row < type.rows; row++) {
                        const idx = col * type.rows + row;
                        this.emit(`  view.setFloat32(${offset + idx * 4}, data.${field.name}[${idx}], true);`);
                    }
                }
                break;
        }
    }
    generatePipelineFactories(ast) {
        // Group shaders by stage
        const computeShaders = ast.gpuShaders.filter(s => s.stage === 'compute');
        const vertexShaders = ast.gpuShaders.filter(s => s.stage === 'vertex');
        const fragmentShaders = ast.gpuShaders.filter(s => s.stage === 'fragment');
        // Compute pipeline factory
        computeShaders.forEach(shader => {
            this.emit(`/**`);
            this.emit(` * Create compute pipeline for ${shader.name}`);
            this.emit(` */`);
            this.emit(`export async function create${this.capitalize(shader.name)}Pipeline(device: GPUDevice): Promise<GPUComputePipeline> {`);
            this.emit(`  const module = device.createShaderModule({ code: shaderCode });`);
            this.emit(`  return device.createComputePipelineAsync({`);
            this.emit(`    layout: 'auto',`);
            this.emit(`    compute: {`);
            this.emit(`      module,`);
            this.emit(`      entryPoint: '${shader.name}'`);
            this.emit(`    }`);
            this.emit(`  });`);
            this.emit('}');
            this.emit('');
        });
        // Render pipeline factory (pairs vertex + fragment)
        if (vertexShaders.length > 0 && fragmentShaders.length > 0) {
            const vs = vertexShaders[0];
            const fs = fragmentShaders[0];
            this.emit(`/**`);
            this.emit(` * Create render pipeline with ${vs.name} and ${fs.name}`);
            this.emit(` */`);
            this.emit(`export async function createRenderPipeline(`);
            this.emit(`  device: GPUDevice,`);
            this.emit(`  format: GPUTextureFormat = navigator.gpu.getPreferredCanvasFormat()`);
            this.emit(`): Promise<GPURenderPipeline> {`);
            this.emit(`  const module = device.createShaderModule({ code: shaderCode });`);
            this.emit(`  return device.createRenderPipelineAsync({`);
            this.emit(`    layout: 'auto',`);
            this.emit(`    vertex: {`);
            this.emit(`      module,`);
            this.emit(`      entryPoint: '${vs.name}'`);
            this.emit(`    },`);
            this.emit(`    fragment: {`);
            this.emit(`      module,`);
            this.emit(`      entryPoint: '${fs.name}',`);
            this.emit(`      targets: [{ format }]`);
            this.emit(`    },`);
            this.emit(`    primitive: {`);
            this.emit(`      topology: 'triangle-list'`);
            this.emit(`    }`);
            this.emit(`  });`);
            this.emit('}');
            this.emit('');
        }
    }
    generateReactHooks(_ast) {
        this.emit(`/**`);
        this.emit(` * React hook for Shader3D WebGPU rendering`);
        this.emit(` */`);
        this.emit(`export function useShader3D(canvasRef: React.RefObject<HTMLCanvasElement>) {`);
        this.emit(`  const [device, setDevice] = useState<GPUDevice | null>(null);`);
        this.emit(`  const [error, setError] = useState<string | null>(null);`);
        this.emit(`  const [ready, setReady] = useState(false);`);
        this.emit(``);
        this.emit(`  useEffect(() => {`);
        this.emit(`    if (!canvasRef.current) return;`);
        this.emit(`    if (!navigator.gpu) {`);
        this.emit(`      setError('WebGPU not supported');`);
        this.emit(`      return;`);
        this.emit(`    }`);
        this.emit(``);
        this.emit(`    const init = async () => {`);
        this.emit(`      try {`);
        this.emit(`        const adapter = await navigator.gpu.requestAdapter();`);
        this.emit(`        if (!adapter) throw new Error('No GPU adapter');`);
        this.emit(`        const dev = await adapter.requestDevice();`);
        this.emit(`        setDevice(dev);`);
        this.emit(`        setReady(true);`);
        this.emit(`      } catch (e) {`);
        this.emit(`        setError(String(e));`);
        this.emit(`      }`);
        this.emit(`    };`);
        this.emit(``);
        this.emit(`    init();`);
        this.emit(`  }, [canvasRef]);`);
        this.emit(``);
        this.emit(`  return { device, error, ready };`);
        this.emit(`}`);
        this.emit('');
    }
    generateExports(ast) {
        const exports = ['shaderCode'];
        // Add struct writers
        ast.sharedTypes.forEach(type => {
            exports.push(`${type.name}ByteSize`);
            exports.push(`write${type.name}`);
        });
        // Add pipeline factories
        ast.gpuShaders.forEach(shader => {
            if (shader.stage === 'compute') {
                exports.push(`create${this.capitalize(shader.name)}Pipeline`);
            }
        });
        if (ast.gpuShaders.some(s => s.stage === 'vertex') &&
            ast.gpuShaders.some(s => s.stage === 'fragment')) {
            exports.push('createRenderPipeline');
        }
        if (this.options.react) {
            exports.push('useShader3D');
        }
        // Default export with everything
        this.emit('/** Default export with all shader utilities */');
        this.emit('export default {');
        exports.forEach((exp, i) => {
            this.emit(`  ${exp}${i < exports.length - 1 ? ',' : ''}`);
        });
        this.emit('};');
    }
    typeToTS(type) {
        switch (type.kind) {
            case 'primitive':
                if (type.name === 'bool' || type.name === 'boolean')
                    return 'boolean';
                return 'number';
            case 'vector':
                return `{ x: number; y: number${type.size >= 3 ? '; z: number' : ''}${type.size >= 4 ? '; w: number' : ''} }`;
            case 'matrix':
                return `Float32Array`;
            case 'array':
                const elem = this.typeToTS(type.elementType);
                return `${elem}[]`;
            case 'custom':
                return type.name;
            default:
                return 'unknown';
        }
    }
    calculateByteSize(type) {
        let size = 0;
        let maxAlignment = 4;
        type.fields.forEach(field => {
            const info = this.getTypeInfo(field.type);
            maxAlignment = Math.max(maxAlignment, info.alignment);
            // Align to field alignment
            size = Math.ceil(size / info.alignment) * info.alignment;
            size += info.size;
        });
        // Struct alignment: round up to largest member alignment
        return Math.ceil(size / maxAlignment) * maxAlignment;
    }
    getTypeInfo(type) {
        switch (type.kind) {
            case 'primitive':
                return { size: 4, alignment: 4 }; // f32, i32, u32 are all 4 bytes
            case 'vector':
                // vec2 = 8 bytes, vec3 = 12 (but aligned to 16), vec4 = 16
                const vecSize = type.size * 4;
                const vecAlign = type.size === 2 ? 8 : 16;
                return { size: vecSize, alignment: vecAlign };
            case 'matrix':
                // mat4x4 = 64 bytes, aligned to 16
                return { size: type.rows * type.cols * 4, alignment: 16 };
            case 'array':
                const elemInfo = this.getTypeInfo(type.elementType);
                const count = type.size || 1;
                return { size: elemInfo.size * count, alignment: elemInfo.alignment };
            default:
                return { size: 4, alignment: 4 };
        }
    }
    capitalize(str) {
        return str.charAt(0).toUpperCase() + str.slice(1);
    }
    emit(line) {
        this.output.push(line);
    }
}
/**
 * Generate JavaScript/TypeScript code from AST and WGSL
 */
export function generateJS(ast, wgslCode, options) {
    const generator = new JSCodeGenerator(options);
    return generator.generate(ast, wgslCode);
}
//# sourceMappingURL=codegen-js.js.map